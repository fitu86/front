import { ID } from './types';
export declare type Field = string;
export declare type Item = Record<string, any>;
export declare type PartialItem<T> = {
    [P in keyof T]?: T[P] extends Record<string, any> ? PartialItem<T[P]> : T[P];
};
export declare type OneItem<T extends Item> = PartialItem<T> | null | undefined;
export declare type ManyItems<T extends Item> = {
    data?: PartialItem<T>[] | null;
    meta?: ItemMetadata;
};
export declare type ItemMetadata = {
    total_count?: number;
    filter_count?: number;
};
export declare type Payload = Record<string, any>;
export declare enum Meta {
    TOTAL_COUNT = "total_count",
    FILTER_COUNT = "filter_count"
}
export declare type QueryOne<T> = {
    fields?: keyof T | (keyof T)[] | '*' | '*.*' | '*.*.*' | string | string[];
    search?: string;
    deep?: Record<string, DeepQueryMany<T>>;
    export?: 'json' | 'csv' | 'xml';
    filter?: Filter<T>;
};
export declare type QueryMany<T> = QueryOne<T> & {
    sort?: Sort<T>;
    limit?: number;
    offset?: number;
    page?: number;
    meta?: keyof ItemMetadata | '*';
};
export declare type DeepQueryMany<T> = {
    [K in keyof QueryMany<T> as `_${string & K}`]: QueryMany<T>[K];
};
export declare type Sort<T> = (`${Extract<keyof T, string>}` | `-${Extract<keyof T, string>}`)[];
export declare type FilterOperators = '_eq' | '_neq' | '_contains' | '_ncontains' | '_in' | '_nin' | '_gt' | '_gte' | '_lt' | '_lte' | '_null' | '_nnull' | '_empty' | '_nempty';
export declare type FilterOperator<T, K extends keyof T> = {
    [O in FilterOperators]?: Filter<T> | T[K];
};
export declare type Filter<T> = {
    [K in keyof T]?: FilterOperator<T, K> | string | boolean | number | string[] | Record<string, any>;
};
/**
 * CRUD at its finest
 */
export interface IItems<T extends Item> {
    createOne(item: PartialItem<T>, query?: QueryOne<T>): Promise<OneItem<T>>;
    createMany(items: PartialItem<T>[], query?: QueryMany<T>): Promise<ManyItems<T>>;
    readOne(id: ID, query?: QueryOne<T>): Promise<OneItem<T>>;
    readMany(query?: QueryMany<T>): Promise<ManyItems<T>>;
    updateOne(id: ID, item: PartialItem<T>, query?: QueryOne<T>): Promise<OneItem<T>>;
    updateMany(ids: ID[], item: PartialItem<T>, query?: QueryMany<T>): Promise<ManyItems<T>>;
    deleteOne(id: ID): Promise<void>;
    deleteMany(ids: ID[]): Promise<void>;
}
//# sourceMappingURL=items.d.ts.map