import { IStorage } from '../../storage';
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ITransport, TransportMethods, TransportResponse, TransportOptions } from '../../transport';
export declare type AxiosTransportRefreshHandler = () => Promise<void>;
export declare type AxiosEjector = {
    eject(): void;
};
export declare type AxiosInterceptorFunction<T> = (onFulfilled?: (value: T) => T | Promise<T>, onRejected?: (error: any) => any) => AxiosEjector;
export declare type AxiosInterceptor<T> = {
    intercept: AxiosInterceptorFunction<T>;
};
/**
 * Axios transport implementation
 */
export declare class AxiosTransport implements ITransport {
    private _url;
    private _storage;
    private _refresh;
    _axios: AxiosInstance;
    constructor(url: string, storage: IStorage, refresh?: AxiosTransportRefreshHandler);
    get url(): string;
    set url(value: string);
    get axios(): AxiosInstance;
    get requests(): AxiosInterceptor<AxiosRequestConfig>;
    get responses(): AxiosInterceptor<AxiosResponse>;
    protected request<T = any, R = any>(method: TransportMethods, path: string, data?: Record<string, any>, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    get<T = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T>>;
    head<T = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T>>;
    options<T = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T>>;
    delete<T = any, D = any>(path: string, data?: D, options?: TransportOptions): Promise<TransportResponse<T>>;
    put<T = any, D = any>(path: string, data?: D, options?: TransportOptions): Promise<TransportResponse<T>>;
    post<T = any, D = any>(path: string, data?: D, options?: TransportOptions): Promise<TransportResponse<T>>;
    patch<T = any, D = any>(path: string, data?: D, options?: TransportOptions): Promise<TransportResponse<T>>;
}
//# sourceMappingURL=axios-transport.d.ts.map