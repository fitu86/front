"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const passwords_1 = require("../handlers/passwords");
const utils_1 = require("../utils");
const DefaultExpirationTime = 30000;
class Auth {
    constructor(transport, storage, options) {
        var _a, _b, _c, _d, _e;
        this.options = options || {};
        this.options.mode = (options === null || options === void 0 ? void 0 : options.mode) || (typeof window !== 'undefined' ? 'cookie' : 'json');
        this.options.refresh = (options === null || options === void 0 ? void 0 : options.refresh) || { auto: false, time: DefaultExpirationTime };
        this.options.refresh.auto = (_b = (_a = this.options.refresh) === null || _a === void 0 ? void 0 : _a.auto) !== null && _b !== void 0 ? _b : false;
        this.options.refresh.time = (_d = (_c = this.options.refresh) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : DefaultExpirationTime;
        this.transport = transport;
        this.storage = storage;
        this.timer = false;
        this.refresher = new utils_1.Debouncer(this.refreshToken.bind(this));
        try {
            this.updateRefresh((_e = this.options) === null || _e === void 0 ? void 0 : _e.refresh);
        }
        catch (_f) {
            // Ignore error
        }
    }
    get token() {
        return this.storage.auth_token;
    }
    get password() {
        return (this.passwords = this.passwords || new passwords_1.PasswordsHandler(this.transport));
    }
    get expiring() {
        var _a, _b;
        const expiration = this.storage.auth_expires;
        if (expiration === null) {
            return false;
        }
        const expiringAfter = expiration - ((_b = (_a = this.options.refresh) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : 0);
        return expiringAfter <= Date.now();
    }
    refreshToken(force = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!force && !this.expiring) {
                return false;
            }
            const response = yield this.transport.post('/auth/refresh', {
                refresh_token: this.options.mode === 'json' ? this.storage.auth_refresh_token : undefined,
            }, {
                refreshTokenIfNeeded: false,
            });
            this.updateStorage(response.data);
            this.updateRefresh();
            return {
                access_token: response.data.access_token,
                refresh_token: (_a = response.data) === null || _a === void 0 ? void 0 : _a.refresh_token,
                expires: response.data.expires,
            };
        });
    }
    updateStorage(result) {
        var _a;
        this.storage.auth_token = result.access_token;
        this.storage.auth_refresh_token = (_a = result.refresh_token) !== null && _a !== void 0 ? _a : null;
        if (result.expires) {
            this.storage.auth_expires = Date.now() + result.expires;
        }
        else {
            this.storage.auth_expires = null;
        }
    }
    updateRefresh(options) {
        var _a, _b;
        const expiration = this.storage.auth_expires;
        if (expiration === null) {
            clearTimeout(this.timer);
            return; // Don't auto refresh if there's no expiration time (token auth)
        }
        if (options) {
            this.options.refresh.auto = (_a = options.auto) !== null && _a !== void 0 ? _a : this.options.refresh.auto;
            this.options.refresh.time = (_b = options.time) !== null && _b !== void 0 ? _b : this.options.refresh.time;
        }
        clearTimeout(this.timer);
        let remaining = expiration - this.options.refresh.time - Date.now();
        if (remaining < 0) {
            // It's already expired, try a refresh
            if (expiration < Date.now()) {
                return; // Don't set auto refresh
            }
            else {
                remaining = 0;
            }
        }
        if (this.options.refresh.auto) {
            this.timer = setTimeout(() => {
                this.refresh()
                    .then(() => {
                    // Do nothing
                })
                    .catch(() => {
                    // Do nothing
                });
            }, remaining);
        }
    }
    refresh(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.refresher.debounce(force);
        });
    }
    login(credentials, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            const response = yield this.transport.post('/auth/login', Object.assign({ mode: this.options.mode }, credentials), {
                refreshTokenIfNeeded: false,
                sendAuthorizationHeaders: false,
            });
            this.updateStorage(response.data);
            this.updateRefresh(options.refresh);
            return {
                access_token: response.data.access_token,
                refresh_token: (_a = response.data) === null || _a === void 0 ? void 0 : _a.refresh_token,
                expires: response.data.expires,
            };
        });
    }
    static(token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.transport.get('/users/me', {
                params: {
                    access_token: token,
                },
            });
            this.storage.auth_token = token;
            this.storage.auth_expires = null;
            this.storage.auth_refresh_token = null;
            return true;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            let refresh_token;
            if (this.options.mode === 'json') {
                refresh_token = this.storage.auth_refresh_token || undefined;
            }
            yield this.transport.post('/auth/logout', {
                refresh_token,
            }, {
                refreshTokenIfNeeded: false,
            });
            this.storage.auth_token = null;
            this.storage.auth_expires = null;
            this.storage.auth_refresh_token = null;
            clearTimeout(this.timer);
        });
    }
}
exports.Auth = Auth;
