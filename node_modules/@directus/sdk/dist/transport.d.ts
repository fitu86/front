import { ItemMetadata } from './items';
export declare type TransportErrorDescription = {
    message?: string;
    extensions?: Record<string, any> & {
        code?: string;
    };
};
export declare type TransportResponse<T, R = any> = {
    raw: R;
    data?: T;
    meta?: ItemMetadata;
    errors?: TransportErrorDescription[];
    status: number;
    statusText?: string;
    headers: any;
};
export declare type TransportMethods = 'get' | 'delete' | 'head' | 'options' | 'post' | 'put' | 'patch';
export declare type TransportOptions = {
    params?: any;
    headers?: any;
    refreshTokenIfNeeded?: boolean;
    sendAuthorizationHeaders?: boolean;
    onUploadProgress?: ((progressEvent: any) => void) | undefined;
};
export interface ITransport {
    url: string;
    get<T = any, R = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    head<T = any, R = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    options<T = any, R = any>(path: string, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    delete<T = any, P = any, R = any>(path: string, data?: P, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    post<T = any, P = any, R = any>(path: string, data?: P, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    put<T = any, P = any, R = any>(path: string, data?: P, options?: TransportOptions): Promise<TransportResponse<T, R>>;
    patch<T = any, P = any, R = any>(path: string, data?: P, options?: TransportOptions): Promise<TransportResponse<T, R>>;
}
export declare class TransportError<T = any, R = any> extends Error {
    readonly errors: TransportErrorDescription[];
    readonly response?: Partial<TransportResponse<T, R>>;
    readonly parent: Error | null;
    constructor(parent: Error | null, response?: Partial<TransportResponse<T, R>>);
}
//# sourceMappingURL=transport.d.ts.map